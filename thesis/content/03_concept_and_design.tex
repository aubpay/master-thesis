\chapter{Concept and Design}
\label{cha:conceptanddesign}

As stated in the research statement, the goal of this thesis is to come up with a solution that solves the unpaid content problem. During the first phase of this research, several opportunities are explored. This chapter gives a chronological overview of these explorations and describes the final model in detail.

\section{Privacy preserving ad network}
In the beginning, the main focus laid at privacy issues that are coming with the use of ad networks. In order to solve this issue, a concept is created where the tracking and profile building moved from the ad network to the browser of the user. By using such an approach, the ad network does not know your browsing history and might even benefit from the new approach, because the browser is able to build a profile that is much more accurate. 

The problem with this concept is actively being researched. For example, it implemented in the Privad system, which can be found in section \ref{sec:privad} system and the Brave browser, which is discussed in section \ref{sec:brave}. Therefore, this concept is abandoned in an early stage.

\section{Universal automated payment solution}
The second concept goes one step further. This concept is not about replacing the ad network with a privacy friendly alternative, but making the entire ad network obsolete. As discussed in chapter \ref{cha:relatedwork}, the problem with ad networks is that is one of the few revenue models that actually works on the internet.

Several commercial experiments are performed using micropayments, however, as stated in chapter \ref{cha:relatedwork}, very few of them are successful. Mainly because of the mental transaction cost that comes with the purchase of online content. In order to solve this issue, the concept of automated payments is introduced. This approach applies the advantage of web advertisements (no browsing interruption) with the benefit of micropayments (no ads). It might also be explained as a fair ad blocker. No ads, but also taking care of the revenue of the publisher. The goal of this concept is to offer such a system with as minimal configuration as possible.

Concept: \textit{Distribute a small amount of money over the publishers that you visit and hide the advertisements}

\subsection{WebRTC approach}

In order to stick to the zeroconf principle, the system should work out of the box, no configuration needed, this first approach includes WebRTC. WebRTC is a system that enables two browsers to create a peer to peer connections to eachother.

This concept assumes that there is a system running that handles all the automated payments to the publisher. The first problem that needs to be solved is: how does the website communicate with the system. Installing an add-on in the browser would violate the zeroconf principle, so this approach uses WebRTC as a message bus. Why WebRTC, you might ask? As WebRTC makes it possible for browsers to communicate with eachother, it is also possible to let different websites communicate to eachother in the same browser. Normally, this is not so easy because every website runs in a sandboxed environment. For example, if \textit{derspiegel.de} want to communicate with a system on \textit{payjs.io}, that is only possible if there is a link between both websites, such as an iframe or that one of the websites opened a tab to the other one. 

WebRTC connects to an ip address, so what happens if we connect to localhost? Is it possible to let two websites communicate without a link between them? The WebRTC is indeed able to connect to localhost, but in order to do so, a handshake is needed \cite{dutton2013webrtc}. This handshake, however is not specified in the WebRTC protocoll. This means that system can implement its own way of doing so. WebRTC-systems that are applied on the internet are mostly relying on a signaling server, which forwards the handshake. 

During this research, several experiments are performed using WebRTC. Unfortunately, the experiments turned out that it is not possible to connect two websites within one browser directly. A signaling server that is run by a third party stays neccesary. This would introduce a privacy problem, because the third party would be able to find out which publisher is visited from which ip. Therefore, this concept is abandoned in an early stage.
\subsection{Lightning network}

The aproach above, however, does not include any form of payment. In the first stage, the scope is limited to a universal payment system, without taking care of the payment itself. It is assumed that there is a cryptocurrency solution that can be attached to the universal payment system.

Fortunately, parallel to this research, a micropament solution based on the Bitcoin blockchain is being actively developed. This so-called Lightning Network is discussed in section \ref{sec:lightning} in more detail. The goal of this system is to provide instant micropayments at minimal costs, which is ideal an automated payment solution.

From the concept point of view, the payment part is a matter of communicating with an API. Nonetheless, are there still some issues with the Lightning Network so that it is not ready to use. One of the main disadvantages of the Lightning Network is that it is not possible to send a transaction to an address directly. By design, a payment should be requested by issuing an invoice. This invoice is written according to a standard format and can be paid using any Lightning Network client. This invoice-based structue suboptimal for the usecase that is needed for this research.

\subsection{Localhost approach}

As the concept where WebRTC is applied in order to let the publisher communicate with the system is not viable, this research is extended to other approaches. One approach that is used by other websites to communicate with the users' computer is by running a webserver. This webserver can be accessed from any website by connecting to localhost. For example, the popular video conferencing application Zoom uses this approach so that the application gets opened when a user visits a meeting url \cite{zoomwebserver}.

As this concept is built in combination with the Lighting Network, there needs to be an application running on the users' computer anyway. So, this makes it possible to develop one service needs to be installed which both acts like a lightning network client and an interface on localhost to the website that requests a payment.

\subsection{Dynamic contribution}

\subsection{DNS TXT-record}

\subsection{Self-signed, DV, OV and EV certificates}

One of the problems with an automated payment system is: how can be determined if a publisher is trustworthy? For example: what happens if some malicious publisher buys a bunch of domain names and opens 50 tabs on the users' computer? Does the system make a payment to all of those 50 domains? 

One approach would be to assign one party that is able to determine which publisher is trustworthy and which one is not. This would violate the decentral principle and is therefore not desirable. Another approach that is discussed is to calculate some kind of score, such as pagerank, and use this score to value the credibility of the publisher. Based on this credibility, a payment might be made or might be adjusted. For example: the domain name \textit{spiegel.de} has a pagerank score of 8/10 where \textit{gartenforum.de} has a pagerank score of 3/10. However, this does not indicate the trustworthyness of a publisher. There is no legitimate reason to pay more to a big publisher that to a small independant content creator. 

Fortunately, there is already a worldwide decentral system in place that validates credibility of websites: SSL certificates. SSL certificates, that are needed in order to establish an encrypted connection to a website are also applied to make sure that the user is communicating with the website that it pretents to be. In order to understand this concept, a short introduction to the different types of certificates and architecture is given. First, a certificate needs to be issued by an authority. The credibility of the certifcate is based on this credibility of the issuer. If some publisher issues the certificate by themselves, it is called a self-signed certificate and this provides no creditbility other than that the connection is encrypted, but there is no guarantee that the party on the other end of the line is the party that they are pretending to be. If the issuer is a trusted party, the certifciate is called a certification authority (CA) certifciate. These CA's are trusted by the browser or SSL library, and they are doing a couple of background checks before they are issuing a certificte. The level of background checks is dependent on the type of certifciate. 

The least secure type of CA certificate is the Domain Validation (DV) certifciate. 


% The proposed solution is an implementation which is completely based on the existing infrastructure that is available on the web. This comes with the advance that it works across all different types of devices, from desktop computers to smartphones. Another feature of this approach is that it does not require any additional tools, which might need some effort tosetup.

% \section{Architecture}
% There are basically two components in this system: there is a wallet, which takes care of the storage of encryption keys and is responsible for handling all communications with a cryptocurrency network. The second part is the publisher library, which can be embedded by any website who want to take part in the universal-pay ecosystem. 

% \subsection{Wallet}
% \label{sec:wallet}
% The wallet will be, like all the other parts of the architecture, implemented in standard web technology, which means Javascript. For the convenience of the end user, the wallet will be hosted on a domain to make sure that for the system to work, still no additional configuration is needed. However, this requires trust. If the owner of the domain becomes malicious, the entire wallet might be stolen. Therefore, the user is free to host his own wallet on every desired location, even \textit{localhost} is a possiblity.

% \subsection{Publisher library}
% Publishers can load an external library into their website, this library communicates with the wallet, as described in \ref{sec:wallet}. When the user visits the page of the publisher, the loaded library will check if there is a wallet running on that local machine. If this is not the case, it will embed the hosted instance of the wallet in an iframe. 

% If the connection with the wallet is established, the publisher will ask the wallet for a payment. The wallet can accept this payment and create a transaction which is sent to the blockchain network.

% \subsection{Communication}
% One of the challenges with this architecture it the communication and how to make sure a connection is established with a publisher that actually is legit and provides content on the users' computer. 

% In order to make this possible, a structure with WebRTC is proposed. WebRTC is a technology which makes it possible for different websites (even accross different computers) to communicate with eachother. The technology was invented to make real time video and audio communication possible within the browser. However, the API makes it also possible to send data over the channel. 

% \subsection{Micropayments}
